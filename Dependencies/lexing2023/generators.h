
//                         Aladdin Free Public License
//                      (Version 9, September 18, 2000)
//
//    Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000 Aladdin Enterprises,
//            Menlo Park, California, U.S.A. All rights reserved.
//
//     NOTE: This License is not the same as any of the GNU Licenses
//     published by the Free Software Foundation. Its terms are
//     substantially different from those of the GNU Licenses. If you are
//     familiar with the GNU Licenses, please read this license with
//     extra care.
//
// Aladdin Enterprises hereby grants to anyone the permission to apply this
// License to their own work, as long as the entire License (including the
// above notices and this paragraph) is copied with no changes, additions, or
// deletions except for changing the first paragraph of Section 0 to include a
// suitable description of the work to which the license is being applied and
// of the person or entity that holds the copyright in the work, and, if the
// License is being applied to a work created in a country other than the
// United States, replacing the first paragraph of Section 6 with an
// appropriate reference to the laws of the appropriate country.

// This License is not an Open Source license: among other things, it places
// restrictions on distribution of the Program, specifically including sale of
// the Program. While Aladdin Enterprises respects and supports the philosophy
// of the Open Source Definition, and shares the desire of the GNU project to
// keep licensed software freely redistributable in both source and object
// form, we feel that Open Source licenses unfairly prevent developers of
// useful software from being compensated proportionately when others profit
// financially from their work. This License attempts to ensure that those who
// receive, redistribute, and contribute to the licensed Program according to
// the Open Source and Free Software philosophies have the right to do so,
// while retaining for the developer(s) of the Program the power to make those
// who use the Program to enhance the value of commercial products pay for the
// privilege of doing so.

// 0. Subject Matter

// This License applies to the parser generator "Maphoon" and all
// of its subparts. In the rest of this license, Maphoon will be 
// referred to as "The Program". The Program is a copyrighted
// work whose copyright is with Hans de Nivelle, living in Dresden, Germany. 
// In the rest of license, "Hans de Nivelle" will be referred to as "Licensor".
// A "work based on the Program" means either the Program or any derivative
// work of the Program, as defined in the United States Copyright Act of 1976,
// such as a translation or a modification.

// BY MODIFYING OR DISTRIBUTING THE PROGRAM (OR ANY WORK BASED ON THE PROGRAM),
// YOU INDICATE YOUR ACCEPTANCE OF THIS LICENSE TO DO SO, AND ALL ITS TERMS AND
// CONDITIONS FOR COPYING, DISTRIBUTING OR MODIFYING THE PROGRAM OR WORKS BASED
// ON IT. NOTHING OTHER THAN THIS LICENSE GRANTS YOU PERMISSION TO MODIFY OR
// DISTRIBUTE THE PROGRAM OR ITS DERIVATIVE WORKS. THESE ACTIONS ARE PROHIBITED
// BY LAW. IF YOU DO NOT ACCEPT THESE TERMS AND CONDITIONS, DO NOT MODIFY OR
// DISTRIBUTE THE PROGRAM.

// 1. Licenses.

// Licensor hereby grants you the following rights, provided that you comply
// with all of the restrictions set forth in this License and provided,
// further, that you distribute an unmodified copy of this License with the
// Program:

// (a)  You may copy and distribute literal (i.e., verbatim) copies of the
//      Program's source code as you receive it throughout the world, in any
//      medium.
// (b)  You may modify the Program, create works based on the Program and
//      distribute copies of such throughout the world, in any medium.

// 2. Restrictions.

// This license is subject to the following restrictions:

// (a)  Distribution of the Program or any work based on the Program by a
//      commercial organization to any third party is prohibited if any payment
//      is made in connection with such distribution, whether directly (as in
//      payment for a copy of the Program) or indirectly (as in payment for
//      some service related to the Program, or payment for some product or
//      service that includes a copy of the Program "without charge"; these are
//      only examples, and not an exhaustive enumeration of prohibited
//      activities). The following methods of distribution involving payment
//      shall not in and of themselves be a violation of this restriction:
//      (i)  Posting the Program on a public access information storage and
//           retrieval service for which a fee is received for retrieving
//           information (such as an on-line service), provided that the fee is
//           not content-dependent (i.e., the fee would be the same for
//           retrieving the same volume of information consisting of random
//           data) and that access to the service and to the Program is
//           available independent of any other product or service. An example
//           of a service that does not fall under this section is an on-line
//           service that is operated by a company and that is only available
//           to customers of that company. (This is not an exhaustive
//           enumeration.)
//      (ii) Distributing the Program on removable computer-readable media,
//           provided that the files containing the Program are reproduced
//           entirely and verbatim on such media, that all information on such
//           media be redistributable for non-commercial purposes without
//           charge, and that such media are distributed by themselves (except
//           for accompanying documentation) independent of any other product
//           or service. Examples of such media include CD-ROM, magnetic tape,
//           and optical storage media. (This is not intended to be an
//           exhaustive list.) An example of a distribution that does not fall
//           under this section is a CD-ROM included in a book or magazine.
//           (This is not an exhaustive enumeration.)
// (b)  Activities other than copying, distribution and modification of the
//      Program are not subject to this License and they are outside its scope.
//      Functional use (running) of the Program is not restricted, and any
//      output produced through the use of the Program is subject to this
//      license only if its contents constitute a work based on the Program
//      (independent of having been made by running the Program).
// (c)  You must meet all of the following conditions with respect to any work
//      that you distribute or publish that in whole or in part contains or is
//      derived from the Program or any part thereof ("the Work"):
//      (i)  If you have modified the Program, you must cause the Work to carry
//           prominent notices stating that you have modified the Program's
//           files and the date of any change. In each source file that you
//           have modified, you must include a prominent notice that you have
//           modified the file, including your name, your e-mail address (if
//           any), and the date and purpose of the change;
//      (ii) You must cause the Work to be licensed as a whole and at no charge
//           to all third parties under the terms of this License;
//      (iii)
//           If the Work normally reads commands interactively when run, you
//           must cause it, at each time the Work commences operation, to print
//           or display an announcement including an appropriate copyright
//           notice and a notice that there is no warranty (or else, saying
//           that you provide a warranty). Such notice must also state that
//           users may redistribute the Work only under the conditions of this
//           License and tell the user how to view the copy of this License
//           included with the Work. (Exceptions: if the Program is interactive
//           but normally prints or displays such an announcement only at the
//           request of a user, such as in an "About box", the Work is required
//           to print or display the notice only under the same circumstances;
//           if the Program itself is interactive but does not normally print
//           such an announcement, the Work is not required to print an
//           announcement.);
//      (iv) You must accompany the Work with the complete corresponding
//           machine-readable source code, delivered on a medium customarily
//           used for software interchange. The source code for a work means
//           the preferred form of the work for making modifications to it. For
//           an executable work, complete source code means all the source code
//           for all modules it contains, plus any associated interface
//           definition files, plus the scripts used to control compilation and
//           installation of the executable code. If you distribute with the
//           Work any component that is normally distributed (in either source
//           or binary form) with the major components (compiler, kernel, and
//           so on) of the operating system on which the executable runs, you
//           must also distribute the source code of that component if you have
//           it and are allowed to do so;
//      (v)  If you distribute any written or printed material at all with the
//           Work, such material must include either a written copy of this
//           License, or a prominent written indication that the Work is
//           covered by this License and written instructions for printing
//           and/or displaying the copy of the License on the distribution
//           medium;
//      (vi) You may not impose any further restrictions on the recipient's
//           exercise of the rights granted herein.

// If distribution of executable or object code is made by offering the
// equivalent ability to copy from a designated place, then offering equivalent
// ability to copy the source code from the same place counts as distribution
// of the source code, even though third parties are not compelled to copy the
// source code along with the object code.

// 3. Reservation of Rights.

// No rights are granted to the Program except as expressly set forth herein.
// You may not copy, modify, sublicense, or distribute the Program except as
// expressly provided under this License. Any attempt otherwise to copy,
// modify, sublicense or distribute the Program is void, and will automatically
// terminate your rights under this License. However, parties who have received
// copies, or rights, from you under this License will not have their licenses
// terminated so long as such parties remain in full compliance.

// 4. Other Restrictions.

// If the distribution and/or use of the Program is restricted in certain
// countries for any reason, Licensor may add an explicit geographical
// distribution limitation excluding those countries, so that distribution is
// permitted only in or among countries not thus excluded. In such case, this
// License incorporates the limitation as if written in the body of this
// License.

// 5. Limitations.

// THE PROGRAM IS PROVIDED TO YOU "AS IS," WITHOUT WARRANTY. THERE IS NO
// WARRANTY FOR THE PROGRAM, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. THE ENTIRE
// RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD
// THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
// REPAIR OR CORRECTION.

// IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
// LICENSOR, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM
// AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL,
// SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
// INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
// DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES
// OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF
// SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
// DAMAGES.

// 6. General.

// This License is governed by the copyright laws of the European Union, 
// excluding choice of law rules.

// If any part of this License is found to be in conflict with the law, that
// part shall be interpreted in its broadest meaning consistent with the law,
// and no other parts of the License shall be affected.

// For United States Government users, the Program is provided with RESTRICTED
// RIGHTS. If you are a unit or agency of the United States Government or are
// acquiring the Program for any such unit or agency, the following apply:

//     If the unit or agency is the Department of Defense ("DOD"), the
//     Program and its documentation are classified as "commercial
//     computer software" and "commercial computer software
//     documentation" respectively and, pursuant to DFAR Section
//     227.7202, the Government is acquiring the Program and its
//     documentation in accordance with the terms of this License. If the
//     unit or agency is other than DOD, the Program and its
//     documentation are classified as "commercial computer software" and
//     "commercial computer software documentation" respectively and,
//     pursuant to FAR Section 12.212, the Government is acquiring the
//     Program and its documentation in accordance with the terms of this
//     License.




#ifndef MAPH_LEXING_GENERATORS_
#define MAPH_LEXING_GENERATORS_  

#include <functional>
#include <iostream>
#include <fstream>
#include <sstream>
#include <map>

#include "indentation.h"
#include "deterministic.h"
 
namespace lexing
{
   // Ensure the token classes print different
   // If two two classes print in the same way,
   // any printed automaton code will be incorrect. 
   // This can happen in the user defines the print function of T.

   template< typename T >
   void checkTprintable( 
      const std::vector<T> & classifications, 
      const std::function< void( std::ostream& out, const T& t ) > & printT )
   {
      std::map< std::string, T > prints;       

      for( const auto& t : classifications ) 
      {
         std::ostringstream repr;
         printT( repr, t );
         auto p = prints. insert( std::pair( repr. str( ), t )); 
         if( !p. second && p. first -> second != t )
         {
            std::cout << "two token classes have the same representation: "; 
            std::cout << repr. str( ) << "\n";
            throw std::runtime_error( "quitting" );  
         }
      }
   }


   // Generates a function that returns a deterministic classifier from table

   template< typename C, typename T >
   void printdeterministic( 
      const std::string& Cname, const std::string& Tname,
      const std::string& name, 
      const classifier<C,T> & cl, std::ostream& file,
      const std::function< void( std::ostream& out, const C& c ) > & printC,
      const std::function< void( std::ostream& out, const T& t ) > & printT,
      indentation ind = indentation( ))
   {
      for( const auto& d : cl. delta )
      {
         if( d. eps. size( ))
            throw std::runtime_error(
                     "printdeterministic: classifier is not deterministic" );
      }

      checkTprintable( cl. classifications, printT );

      file << "\n";
      file << ind << "lexing::deterministic< ";
      file << Cname << ", " << Tname << " > ";
      file << name << "( )\n{\n";

      ind += 3;

      file << ind << "std::vector< lexing::deterministic< ";
      file << Cname << ", " << Tname << " > :: state_info > st = ";
      file << "{";
      
      size_t start = 0;
      for( size_t i = 0; i != cl. nrstates(); ++ i ) 
      {
         if( i != 0 )
            file << ", ";

         if( i % 4 == 0 )
            file << "\n" << (ind+3);

         file << "{ " << start << ", ";
         printT( file, cl. classifications[i] );
         file << " }";  

         start += cl. delta[i]. noneps. size( ); 
      }
      file << "\n" << ind << "};\n";
      file << "\n";

      file << ind << "std::vector< lexing::deterministic< ";
      file << Cname << ", " << Tname << " > :: trans > tr =\n";
      file << ind << "{";

      size_t nr = 0; 
      for( size_t i = 0; i != cl. nrstates(); ++ i )
      {
         for( const auto& p : cl. delta[i]. noneps )
         {
            if( nr != 0 )
               file << ", ";

            if( nr % 5 == 0 )
               file << "\n" << (ind+3);

            file << "{ "; 
            printC( file, p. first );
            file << ", ";  
            if( p. second == blocked )
               file << deterministic<C,T> :: blocked; 
            else
               file << i + p. second;

            file << " }";
            ++ nr;
         }
      }

      file << "\n"; 
      file << ind << "};\n\n";

      file << ind << "return lexing::deterministic< ";
      file << Cname << ", " << Tname << " > ";
      file << "( std::move(st), std::move(tr) );\n}\n";
      file << "\n";
   }


   // The map singleton maps decisions (relative state transitions
   // represented by integers which can be 'blocked') 
   // to the characters (C) that have them.
   // totalsize adds the total number of transitions.
   // If have has a/2 b/2  c/ blocked, d/ blocked,
   // we have 2 -> (a,b)   blocked -> (c,d). 

   template< typename C > 
   size_t totalsize( const std::map< int, std::vector<C>> & singletons )
   {
      size_t s = 0;
      for( const auto& p : singletons )
         s += p. second. size( );
      return s;
   }


   template< typename C >
   std::ostream& 
   operator << ( std::ostream& out, 
                 const std::map< int, std::vector<C>> & singletons )
   {
      for( const auto& s : singletons )
      {
         out << s. first << "      : { " ;
         for( auto p = s. second. begin( ); p != s. second. end( ); ++ p )
         {
            if( p != s. second. begin( ))
               out << ", ";
            out << *p; 
         }
         out << " }\n";
      }
      out << "\n";
      return out; 
   }


   // Separate delta into the singletons, and the rest.

   template< typename C >
   std::pair< std::map< int, std::vector<C>>,
              flatmap< C, int >>
   getsingletons( const flatmap<C,int> & delta )
   {
      flatmap<C,int> delta_reduced;
      std::map<int, std::vector<C>> singles; 

      for( auto p = delta. begin(); p != delta. end(); ++p )
      {
         // if the beginning of the next interval is the next character
         // after the beginning of the current interval, add it to map
         // otherwise, it stays in the border function

         auto p1 = p;
         ++ p1; 

         if( ( p1 != delta. end( ) &&
               p -> first != maxval<C> ( ) && p -> first + 1 == p1 -> first ) ||
             ( p == delta. end( ) && p -> first == maxval<C> ( ))) 
         {
            singles[ p -> second ]. push_back( p -> first ); 
         }
         else
            delta_reduced.append( p -> first, p -> second );
      }
      return std::make_pair( std::move( singles ), std::move( delta_reduced )); 
   }


   template< typename C, typename T >
   void singleton_iforswitch( state s,
      const std::map< int, std::vector<C>> & singletons, 
      indentation ind, std::ostream& file,
      const std::function< void( std::ostream& out, const C& c )> & printC,
      const std::function< void( std::ostream& out, const T& t )> & printT )
   {
      if( totalsize( singletons ) < 4 )
      {
         for( const auto& opt : singletons )
         {
            file << ind << "if( "; 
            for( auto p = opt. second. begin( ); p != opt. second. end( ); ++ p )
            {
               if( p != opt. second. begin( ))
                  file << " || "; 
               file << "c == ";
               printC( file, *p );
            }
            file << " ) ";

            if( opt. first == blocked )
               file << "return latest;\n";
            else
               file << "{ ++ i; goto " << state( s + opt. first ) << "; }\n";
         }
      }
      else
      {
         file << ind << "switch( c )\n";
         file << ind << "{\n"; 

         for( const auto& opt : singletons )
         {
            for( const auto& c : opt. second ) 	
            {
               file << ind << "case ";
               printC( file, c );
               file << ":\n";
            }

            if( opt. first == blocked )
               file << (ind+3) << "return latest;\n";
            else
               file << (ind+3) << "++ i; goto " << state( s + opt. first ) << ";\n";
         }

         file << ind << "}\n";
      }
   }


   template< typename C, typename T >
   void linear_if( state s, 
      typename flatmap<C,int> :: const_iterator begin,
      typename flatmap<C,int> :: const_iterator end, 
      indentation ind, std::ostream& file, 
      const std::function< void( std::ostream& out, const C& c )> & printC,
      const std::function< void( std::ostream& out, const T& t )> & printT )
   {
      if( begin > end )
         throw std::logic_error( "order is wrong" );

      auto p = end; 
      while( p != begin ) 
      {
         -- p;

         if( p == begin )
            file << ind << "if constexpr( true ) ";
         else
         {
            file << ind << "if( c >= "; 
            printC( file, p -> first ); 
            file << " ) ";
         }
 
         if( p -> second == blocked )
            file << "return latest;\n";
         else
            file << "{ ++ i; goto " << state( s + p -> second ) << "; }\n";
      }
   }


   template< typename C, typename T >
   void binary_if( state s,
      typename flatmap<C,int> :: const_iterator begin,
      typename flatmap<C,int> :: const_iterator end,
      indentation ind, std::ostream& file,
      const std::function< void( std::ostream& out, const C& c )> & printC,
      const std::function< void( std::ostream& out, const T& t )> & printT )
   {
      if( end - begin < 5 )
      {
         linear_if( s, begin, end, ind, file, printC, printT );
      }
      else
      { 
         // We split in the middle:

         auto middle = begin + (( end - begin ) >> 1 ); 

         file << ind << "if( c >= "; 
         printC( file, middle -> first ); 
         file << " )\n";
         file << ind << "{\n";
         binary_if( s, middle, end, ind+3, file, printC, printT ); 
         file << ind << "}\n";
         file << ind << "else\n";
         file << ind << "{\n";
         binary_if( s, begin, middle, ind+3, file, printC, printT );
         file << ind << "}\n";  
      }
   }

   // This function generates C++ code for a working classifier.
   // The resulting program has the same interface as readandclassify.
   // The code follows the paper.
   // Cname : name of the C-type.
   // Tname : name of the T-type
   // Sname : name of the source type. It must have .has( ) and .peek( )
   // name : name of the function that we will create. 
   // Function printC prints a C, while
   // function printT prints a T.

   template< typename C, typename T >
   void printcode( 
      const std::string& Cname, const std::string& Tname, 
      const std::vector< std::string > & nspace, 
      const classifier<C,T> & cl, std::ostream& file,
      const std::function< void( std::ostream& out, const C& t ) > & printC,
      const std::function< void( std::ostream& out, const T& t ) > & printT,
      indentation ind = indentation( )) 
   {
      for( const auto& d : cl. delta )
      {
         if( d. eps. size( ))
            throw std::runtime_error(
                    "lexing::printcode: classifier is not deterministic" );
      }

      checkTprintable( cl. classifications, printT );  

      file << "\n";
      file << ind << "// This code was generated automatically.\n"; 
      file << ind << "// Generator written by Hans de Nivelle and ";
      file << ind << "Dina Muktubayeva.\n\n";

      for( const std::string& s : nspace )
         for( char c : s )
         {
            if( !isalnum(c) && c != '_' ) 
               throw std::runtime_error( 
                  "lexing::printcode: namespace is not well-formed" ); 
         }

      for( auto p = nspace. begin( ); p != nspace. end( ); ++ p )
      {
         file << ind << "namespace " << *p << "\n";
         file << ind << "{\n";
         ind += 3;
      }

      file << ind << "namespace\n";
      file << ind << "{\n";
      ind += 3;

      file << ind << "template< typename S >\n";
      file << ind << "std::pair< " << Tname << ", size_t > ";
      file << "readandclassify";
      file << "( int triv, S& inp )\n";
      file << ind << "{\n";
      ind += 3;
      file << ind << "auto latest = std::make_pair< " << Tname << ", size_t > ( ";
      printT( file, cl. errorclass( )); file << ", 0 );\n";
      file << ind << "if( !inp. has(1))\n";
      file << (ind+3) << "return latest;\n";
      file << ind << Cname << " c = inp. peek(0);\n";
      file << ind << "size_t i = 0;\n";
      file << "\n";

      for( size_t i = 0; i < cl.nrstates(); ++ i )
      {
         file << (ind-3) << state(i) << ":\n";
         if( cl. classifications[i] != cl. errorclass( ))
         {
            file << ind << "latest. first = ";
            printT( file, cl.classifications[i] );
            file << "; latest. second = i;\n";
         }

         // If there are no transitions from i, there is no need to look at the
         // next C. 

         if( cl. delta[i]. noneps. size() != 1 ||
             cl. delta[i]. noneps. begin() -> second != blocked )
         {
            file << ind << "if( !inp. has(i+1))\n";
            file << (ind+3) << "return latest;\n";

            file << ind << "c = inp. peek(i);\n";

            if constexpr( false ) 
            {
               // This is debugging information, make it true if you 
               // want to see it. But: If you want to debug
               // the automaton, you probably should not generate the 
               // C++ code, but call readandclassify on the non-deterministic
               // classifier and have it print the state sets. 

               file << ind << "std::cout << \"state Q" << i << ", next ";
               file << Cname << " is \" << c << \"\\n\";";
               file << "\n";
            }

            auto p = getsingletons( cl.delta[i].noneps );
            singleton_iforswitch( state(i), p. first, 
                                  ind, file, printC, printT ); 
            binary_if( state(i), 
                       p. second. begin(),
                       p. second. end(), ind, file, printC, printT );

         }
         else
            file << ind << "return latest;\n"; 
      }
 
      ind -= 3;
      file << ind << "}\n";

      ind -= 3;
      file << ind << "}\n";
       
      for( size_t i = 0; i != nspace. size( ); ++ i )  
      {
         ind -= 3; 
         file << ind << "}\n";
      }

      file << "\n";
   }

}

#endif


