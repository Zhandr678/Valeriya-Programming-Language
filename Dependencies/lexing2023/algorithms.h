
//                         Aladdin Free Public License
//                      (Version 9, September 18, 2000)
//
//    Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000 Aladdin Enterprises,
//            Menlo Park, California, U.S.A. All rights reserved.
//
//     NOTE: This License is not the same as any of the GNU Licenses
//     published by the Free Software Foundation. Its terms are
//     substantially different from those of the GNU Licenses. If you are
//     familiar with the GNU Licenses, please read this license with
//     extra care.
//
// Aladdin Enterprises hereby grants to anyone the permission to apply this
// License to their own work, as long as the entire License (including the
// above notices and this paragraph) is copied with no changes, additions, or
// deletions except for changing the first paragraph of Section 0 to include a
// suitable description of the work to which the license is being applied and
// of the person or entity that holds the copyright in the work, and, if the
// License is being applied to a work created in a country other than the
// United States, replacing the first paragraph of Section 6 with an
// appropriate reference to the laws of the appropriate country.

// This License is not an Open Source license: among other things, it places
// restrictions on distribution of the Program, specifically including sale of
// the Program. While Aladdin Enterprises respects and supports the philosophy
// of the Open Source Definition, and shares the desire of the GNU project to
// keep licensed software freely redistributable in both source and object
// form, we feel that Open Source licenses unfairly prevent developers of
// useful software from being compensated proportionately when others profit
// financially from their work. This License attempts to ensure that those who
// receive, redistribute, and contribute to the licensed Program according to
// the Open Source and Free Software philosophies have the right to do so,
// while retaining for the developer(s) of the Program the power to make those
// who use the Program to enhance the value of commercial products pay for the
// privilege of doing so.

// 0. Subject Matter

// This License applies to the parser generator "Maphoon" and all
// of its subparts. In the rest of this license, Maphoon will be 
// referred to as "The Program". The Program is a copyrighted
// work whose copyright is with Hans de Nivelle, living in Dresden, Germany. 
// In the rest of license, "Hans de Nivelle" will be referred to as "Licensor".
// A "work based on the Program" means either the Program or any derivative
// work of the Program, as defined in the United States Copyright Act of 1976,
// such as a translation or a modification.

// BY MODIFYING OR DISTRIBUTING THE PROGRAM (OR ANY WORK BASED ON THE PROGRAM),
// YOU INDICATE YOUR ACCEPTANCE OF THIS LICENSE TO DO SO, AND ALL ITS TERMS AND
// CONDITIONS FOR COPYING, DISTRIBUTING OR MODIFYING THE PROGRAM OR WORKS BASED
// ON IT. NOTHING OTHER THAN THIS LICENSE GRANTS YOU PERMISSION TO MODIFY OR
// DISTRIBUTE THE PROGRAM OR ITS DERIVATIVE WORKS. THESE ACTIONS ARE PROHIBITED
// BY LAW. IF YOU DO NOT ACCEPT THESE TERMS AND CONDITIONS, DO NOT MODIFY OR
// DISTRIBUTE THE PROGRAM.

// 1. Licenses.

// Licensor hereby grants you the following rights, provided that you comply
// with all of the restrictions set forth in this License and provided,
// further, that you distribute an unmodified copy of this License with the
// Program:

// (a)  You may copy and distribute literal (i.e., verbatim) copies of the
//      Program's source code as you receive it throughout the world, in any
//      medium.
// (b)  You may modify the Program, create works based on the Program and
//      distribute copies of such throughout the world, in any medium.

// 2. Restrictions.

// This license is subject to the following restrictions:

// (a)  Distribution of the Program or any work based on the Program by a
//      commercial organization to any third party is prohibited if any payment
//      is made in connection with such distribution, whether directly (as in
//      payment for a copy of the Program) or indirectly (as in payment for
//      some service related to the Program, or payment for some product or
//      service that includes a copy of the Program "without charge"; these are
//      only examples, and not an exhaustive enumeration of prohibited
//      activities). The following methods of distribution involving payment
//      shall not in and of themselves be a violation of this restriction:
//      (i)  Posting the Program on a public access information storage and
//           retrieval service for which a fee is received for retrieving
//           information (such as an on-line service), provided that the fee is
//           not content-dependent (i.e., the fee would be the same for
//           retrieving the same volume of information consisting of random
//           data) and that access to the service and to the Program is
//           available independent of any other product or service. An example
//           of a service that does not fall under this section is an on-line
//           service that is operated by a company and that is only available
//           to customers of that company. (This is not an exhaustive
//           enumeration.)
//      (ii) Distributing the Program on removable computer-readable media,
//           provided that the files containing the Program are reproduced
//           entirely and verbatim on such media, that all information on such
//           media be redistributable for non-commercial purposes without
//           charge, and that such media are distributed by themselves (except
//           for accompanying documentation) independent of any other product
//           or service. Examples of such media include CD-ROM, magnetic tape,
//           and optical storage media. (This is not intended to be an
//           exhaustive list.) An example of a distribution that does not fall
//           under this section is a CD-ROM included in a book or magazine.
//           (This is not an exhaustive enumeration.)
// (b)  Activities other than copying, distribution and modification of the
//      Program are not subject to this License and they are outside its scope.
//      Functional use (running) of the Program is not restricted, and any
//      output produced through the use of the Program is subject to this
//      license only if its contents constitute a work based on the Program
//      (independent of having been made by running the Program).
// (c)  You must meet all of the following conditions with respect to any work
//      that you distribute or publish that in whole or in part contains or is
//      derived from the Program or any part thereof ("the Work"):
//      (i)  If you have modified the Program, you must cause the Work to carry
//           prominent notices stating that you have modified the Program's
//           files and the date of any change. In each source file that you
//           have modified, you must include a prominent notice that you have
//           modified the file, including your name, your e-mail address (if
//           any), and the date and purpose of the change;
//      (ii) You must cause the Work to be licensed as a whole and at no charge
//           to all third parties under the terms of this License;
//      (iii)
//           If the Work normally reads commands interactively when run, you
//           must cause it, at each time the Work commences operation, to print
//           or display an announcement including an appropriate copyright
//           notice and a notice that there is no warranty (or else, saying
//           that you provide a warranty). Such notice must also state that
//           users may redistribute the Work only under the conditions of this
//           License and tell the user how to view the copy of this License
//           included with the Work. (Exceptions: if the Program is interactive
//           but normally prints or displays such an announcement only at the
//           request of a user, such as in an "About box", the Work is required
//           to print or display the notice only under the same circumstances;
//           if the Program itself is interactive but does not normally print
//           such an announcement, the Work is not required to print an
//           announcement.);
//      (iv) You must accompany the Work with the complete corresponding
//           machine-readable source code, delivered on a medium customarily
//           used for software interchange. The source code for a work means
//           the preferred form of the work for making modifications to it. For
//           an executable work, complete source code means all the source code
//           for all modules it contains, plus any associated interface
//           definition files, plus the scripts used to control compilation and
//           installation of the executable code. If you distribute with the
//           Work any component that is normally distributed (in either source
//           or binary form) with the major components (compiler, kernel, and
//           so on) of the operating system on which the executable runs, you
//           must also distribute the source code of that component if you have
//           it and are allowed to do so;
//      (v)  If you distribute any written or printed material at all with the
//           Work, such material must include either a written copy of this
//           License, or a prominent written indication that the Work is
//           covered by this License and written instructions for printing
//           and/or displaying the copy of the License on the distribution
//           medium;
//      (vi) You may not impose any further restrictions on the recipient's
//           exercise of the rights granted herein.

// If distribution of executable or object code is made by offering the
// equivalent ability to copy from a designated place, then offering equivalent
// ability to copy the source code from the same place counts as distribution
// of the source code, even though third parties are not compelled to copy the
// source code along with the object code.

// 3. Reservation of Rights.

// No rights are granted to the Program except as expressly set forth herein.
// You may not copy, modify, sublicense, or distribute the Program except as
// expressly provided under this License. Any attempt otherwise to copy,
// modify, sublicense or distribute the Program is void, and will automatically
// terminate your rights under this License. However, parties who have received
// copies, or rights, from you under this License will not have their licenses
// terminated so long as such parties remain in full compliance.

// 4. Other Restrictions.

// If the distribution and/or use of the Program is restricted in certain
// countries for any reason, Licensor may add an explicit geographical
// distribution limitation excluding those countries, so that distribution is
// permitted only in or among countries not thus excluded. In such case, this
// License incorporates the limitation as if written in the body of this
// License.

// 5. Limitations.

// THE PROGRAM IS PROVIDED TO YOU "AS IS," WITHOUT WARRANTY. THERE IS NO
// WARRANTY FOR THE PROGRAM, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. THE ENTIRE
// RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD
// THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
// REPAIR OR CORRECTION.

// IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
// LICENSOR, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM
// AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL,
// SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
// INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
// DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES
// OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF
// SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
// DAMAGES.

// 6. General.

// This License is governed by the copyright laws of the European Union, 
// excluding choice of law rules.

// If any part of this License is found to be in conflict with the law, that
// part shall be interpreted in its broadest meaning consistent with the law,
// and no other parts of the License shall be affected.

// For United States Government users, the Program is provided with RESTRICTED
// RIGHTS. If you are a unit or agency of the United States Government or are
// acquiring the Program for any such unit or agency, the following apply:

//     If the unit or agency is the Department of Defense ("DOD"), the
//     Program and its documentation are classified as "commercial
//     computer software" and "commercial computer software
//     documentation" respectively and, pursuant to DFAR Section
//     227.7202, the Government is acquiring the Program and its
//     documentation in accordance with the terms of this License. If the
//     unit or agency is other than DOD, the Program and its
//     documentation are classified as "commercial computer software" and
//     "commercial computer software documentation" respectively and,
//     pursuant to FAR Section 12.212, the Government is acquiring the
//     Program and its documentation in accordance with the terms of this
//     License.




#ifndef MAPH_LEXING_ALGORITHMS_
#define MAPH_LEXING_ALGORITHMS_  1

#include "acceptor.h"
#include "classifier.h"
#include "state.h"
#include "stateset.h" 
#include <stack>
#include "concepts.h"

#include <unordered_map>

namespace lexing
{

   template< typename C > stateset
   eps_closure( const std::vector< deltafromstate<C>> & delta,
                const stateset& start )
   {
      stateset closure;

      std::stack<state> unchecked;

      for( auto st : start )
      {
         closure. insert( st );
         unchecked. push( st );
      }

      // unchecked is always a subset of closure.

      while( !unchecked. empty() ) 
      {
         state s = unchecked.top();
         unchecked.pop();

         // i enumerates the states that are reachable by epsilon 
         // transition from s. 
         // Since i is always relative, we have to check ( s + i ).

	 for( int i : delta[ s.nr ]. eps ) 
         {
	    // check if the state has been visited

	    if( !closure. contains( s + i ))
            {
               unchecked.push( s + i );
               closure.insert( s + i );
            }
         }
      }

      return closure;
   }


   // Returns the c-transition from the given set of states

   template< typename C > stateset
   transition( const std::vector< deltafromstate<C>> & delta,
               const stateset& from, C c ) 
   {
      stateset result; 

      // Insert c-transitions from every state in from:

      for( auto st : from ) 
      {
         auto p = delta[ st.nr ].noneps.find(c); 

         // check if p points to valid offset value

         if( p -> second != blocked ) 
            result. insert( st + p -> second );
      }

      return result;
   }


   // Returns the set of borders of the transition functions
   // of the states in set. 

   template< typename C >
   std::set<C> borders( const std::vector< deltafromstate<C>> & delta, 
                        const stateset& set ) 
   {
      std::set<C> res;

      for( auto s : set ) 
      {
         for( auto b : delta[ s.nr ]. noneps )
            res. insert( b. first );
      }

      return res;
   }

   // So that we can print character sets:

   template< typename C >
   std::ostream& operator << ( std::ostream& out, const std::set<C> & charset )
   {
      out << "{ ";
      for( auto p = charset. begin( ); p != charset. end( ); ++ p )
      {
         if( p != charset. begin( ))
            out << ", "; 

         if( *p == minval<C> () )
            out << "MIN";
         else
            out << *p;
      }
      out << " }";
      return out;
   }

         
   // Returns the classification given by the maximal state in
   // set from the states that do not classify as error, if at least
   // one state in set does not classify as error. 

   template< typename T > 
   T maxnoterror( const std::vector<T> & cl, T error, 
                  const stateset& set ) 
   {
      auto best = set. begin( );
      while( best != set. end( ) && cl[ best -> nr ] == error )
         ++ best;

      if( best == set. end( ))
         return error;           // No non-error state was found.

      auto p = best;
      ++ p;

      while( p != set. end( )) 
      {
         if( cl[ p -> nr ] != error && *best < *p ) 
         {
            best = p;
         }
         ++ p;
      }      
      return cl[ best -> nr ];
   }


   // Read and classify also works when the classifier is nondeterministic:
   // It is not efficient, but still useful for testing.

   template< typename C, typename T, reader_concept<C> R > 
   std::pair< T, size_t >  
   readandclassify( const classifier<C,T> & cl, R& inp )
   {
      // std::cout << "non deterministic read and classify\n";

      stateset reachable; 
      reachable. insert( state(0) );
      reachable = eps_closure( cl. delta, reachable );

      std::pair<T,size_t> latest = std::make_pair( cl. errorclass( ), 0 );
         // We remember the latest classification that was not error,
         // as soon as we encounter one.

      if( !inp. has(1))
         return latest; 
 
      size_t i = 0; 

      while( true )
      {
         T t = maxnoterror( cl.classifications, cl.errorclass( ), reachable );
         if( t != cl. errorclass( ))
         {
            latest. first = t; 
            latest. second = i; 
         }
 
         // std::cout << "latest classification ";
         // std::cout << latest. first << "/" << latest. second << "\n";

         if( !inp. has( i + 1 )) 
            return latest;
     
         C c = inp. peek(i);

         reachable = transition( cl. delta, reachable, c );

         if( reachable. size( ) == 0 )
            return latest;          // No possible states left. 

         reachable = eps_closure( cl. delta, reachable );

         // std::cout << "move to states " << reachable << "\n";

         ++ i;
      }
   }


   template< typename C, typename T >
   classifier<C,T> 
   make_deterministic( const classifier<C,T> & cl )
   {
      stateset initial;
      initial. insert(0);
      initial = eps_closure( cl. delta, initial ); 

      T error = cl. errorclass( ); 

      // std::cout << "initial = " << initial << "\n";

      for( auto s : initial )
      {
         if( cl. classifications[ s. nr ] != error )
         {
            std::cout << "\n";
            std::cout << "empty word classifies as " << 
            cl. classifications[ s. nr ] << "\n\n";
            throw std::logic_error( "cannot make deterministic" ); 
         }
      }

      // std::cout << "error class = " << error << "\n";
      // std::cout << "\n";

      classifier<C,T> det( error );
      det. delta. clear( );
      det. classifications. clear( );
 
      // Index of subsets that we have obtained in 
      // the subset construction. It maps the constructed subsets
      // to states of det.

      std::unordered_map< stateset, unsigned int, 
                          stateset::hash, stateset::equal_to > index; 

      std::vector< stateset > states; 
         // Constructed states. states[i] is the i-th state in det. 

      // We are now storing subsets twice, but I think it is no problem.
      // States are stored closed, because otherwise we may miss 
      // equal states.

      index. insert( std::make_pair( initial, 0 ));
      states. push_back( initial );
      size_t checking = 0;

      while( checking < states. size( ))
      {
         // std::cout << "checking state " << checking << "\n";
         // std::cout << "set = " << states[ checking ] << "\n";

         std::set<C> bord = borders( cl.delta, states[ checking ] ); 
         // std::cout << "borders = " << bord << "\n";

         T t = maxnoterror( cl. classifications, cl. errorclass( ),
                         states[ checking ] );

         // std::cout << "classification will be " << t << "\n\n";

         flatmap< C, int > noneps; 

         // We will append a transition for each border to noneps: 

         for( auto c : bord )
         {
            // discover the states reachable over the c-transition

            stateset next = transition( cl.delta, states[ checking ], c );
          
	    next  = eps_closure( cl.delta,  next );

            if( next. size( )) 
            {
               auto p = index. insert( std::make_pair( next, states. size( ))); 
               if( p. second )
                  states. push_back( next );

               int rel = state( p. first -> second ) - state( checking ); 
                 // relative difference to the next state. 
                 // If you write it without conversion to state,
                 // result will be unsigned. It will work, but
                 // only coincidentally.  

               noneps. append( c, rel ); 
            }
            else
               noneps. append( c, blocked );
         }

         det. delta. push_back( deltafromstate<C>( std::set<int> ( ), 
                                                   std::move( noneps ) ));
         det. classifications. push_back(t);
         ++ checking; 
      }

      return det; 
   }

}

#endif

