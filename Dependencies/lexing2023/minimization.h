
//                         Aladdin Free Public License
//                      (Version 9, September 18, 2000)
//
//    Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000 Aladdin Enterprises,
//            Menlo Park, California, U.S.A. All rights reserved.
//
//     NOTE: This License is not the same as any of the GNU Licenses
//     published by the Free Software Foundation. Its terms are
//     substantially different from those of the GNU Licenses. If you are
//     familiar with the GNU Licenses, please read this license with
//     extra care.
//
// Aladdin Enterprises hereby grants to anyone the permission to apply this
// License to their own work, as long as the entire License (including the
// above notices and this paragraph) is copied with no changes, additions, or
// deletions except for changing the first paragraph of Section 0 to include a
// suitable description of the work to which the license is being applied and
// of the person or entity that holds the copyright in the work, and, if the
// License is being applied to a work created in a country other than the
// United States, replacing the first paragraph of Section 6 with an
// appropriate reference to the laws of the appropriate country.

// This License is not an Open Source license: among other things, it places
// restrictions on distribution of the Program, specifically including sale of
// the Program. While Aladdin Enterprises respects and supports the philosophy
// of the Open Source Definition, and shares the desire of the GNU project to
// keep licensed software freely redistributable in both source and object
// form, we feel that Open Source licenses unfairly prevent developers of
// useful software from being compensated proportionately when others profit
// financially from their work. This License attempts to ensure that those who
// receive, redistribute, and contribute to the licensed Program according to
// the Open Source and Free Software philosophies have the right to do so,
// while retaining for the developer(s) of the Program the power to make those
// who use the Program to enhance the value of commercial products pay for the
// privilege of doing so.

// 0. Subject Matter

// This License applies to the parser generator "Maphoon" and all
// of its subparts. In the rest of this license, Maphoon will be 
// referred to as "The Program". The Program is a copyrighted
// work whose copyright is with Hans de Nivelle, living in Dresden, Germany. 
// In the rest of license, "Hans de Nivelle" will be referred to as "Licensor".
// A "work based on the Program" means either the Program or any derivative
// work of the Program, as defined in the United States Copyright Act of 1976,
// such as a translation or a modification.

// BY MODIFYING OR DISTRIBUTING THE PROGRAM (OR ANY WORK BASED ON THE PROGRAM),
// YOU INDICATE YOUR ACCEPTANCE OF THIS LICENSE TO DO SO, AND ALL ITS TERMS AND
// CONDITIONS FOR COPYING, DISTRIBUTING OR MODIFYING THE PROGRAM OR WORKS BASED
// ON IT. NOTHING OTHER THAN THIS LICENSE GRANTS YOU PERMISSION TO MODIFY OR
// DISTRIBUTE THE PROGRAM OR ITS DERIVATIVE WORKS. THESE ACTIONS ARE PROHIBITED
// BY LAW. IF YOU DO NOT ACCEPT THESE TERMS AND CONDITIONS, DO NOT MODIFY OR
// DISTRIBUTE THE PROGRAM.

// 1. Licenses.

// Licensor hereby grants you the following rights, provided that you comply
// with all of the restrictions set forth in this License and provided,
// further, that you distribute an unmodified copy of this License with the
// Program:

// (a)  You may copy and distribute literal (i.e., verbatim) copies of the
//      Program's source code as you receive it throughout the world, in any
//      medium.
// (b)  You may modify the Program, create works based on the Program and
//      distribute copies of such throughout the world, in any medium.

// 2. Restrictions.

// This license is subject to the following restrictions:

// (a)  Distribution of the Program or any work based on the Program by a
//      commercial organization to any third party is prohibited if any payment
//      is made in connection with such distribution, whether directly (as in
//      payment for a copy of the Program) or indirectly (as in payment for
//      some service related to the Program, or payment for some product or
//      service that includes a copy of the Program "without charge"; these are
//      only examples, and not an exhaustive enumeration of prohibited
//      activities). The following methods of distribution involving payment
//      shall not in and of themselves be a violation of this restriction:
//      (i)  Posting the Program on a public access information storage and
//           retrieval service for which a fee is received for retrieving
//           information (such as an on-line service), provided that the fee is
//           not content-dependent (i.e., the fee would be the same for
//           retrieving the same volume of information consisting of random
//           data) and that access to the service and to the Program is
//           available independent of any other product or service. An example
//           of a service that does not fall under this section is an on-line
//           service that is operated by a company and that is only available
//           to customers of that company. (This is not an exhaustive
//           enumeration.)
//      (ii) Distributing the Program on removable computer-readable media,
//           provided that the files containing the Program are reproduced
//           entirely and verbatim on such media, that all information on such
//           media be redistributable for non-commercial purposes without
//           charge, and that such media are distributed by themselves (except
//           for accompanying documentation) independent of any other product
//           or service. Examples of such media include CD-ROM, magnetic tape,
//           and optical storage media. (This is not intended to be an
//           exhaustive list.) An example of a distribution that does not fall
//           under this section is a CD-ROM included in a book or magazine.
//           (This is not an exhaustive enumeration.)
// (b)  Activities other than copying, distribution and modification of the
//      Program are not subject to this License and they are outside its scope.
//      Functional use (running) of the Program is not restricted, and any
//      output produced through the use of the Program is subject to this
//      license only if its contents constitute a work based on the Program
//      (independent of having been made by running the Program).
// (c)  You must meet all of the following conditions with respect to any work
//      that you distribute or publish that in whole or in part contains or is
//      derived from the Program or any part thereof ("the Work"):
//      (i)  If you have modified the Program, you must cause the Work to carry
//           prominent notices stating that you have modified the Program's
//           files and the date of any change. In each source file that you
//           have modified, you must include a prominent notice that you have
//           modified the file, including your name, your e-mail address (if
//           any), and the date and purpose of the change;
//      (ii) You must cause the Work to be licensed as a whole and at no charge
//           to all third parties under the terms of this License;
//      (iii)
//           If the Work normally reads commands interactively when run, you
//           must cause it, at each time the Work commences operation, to print
//           or display an announcement including an appropriate copyright
//           notice and a notice that there is no warranty (or else, saying
//           that you provide a warranty). Such notice must also state that
//           users may redistribute the Work only under the conditions of this
//           License and tell the user how to view the copy of this License
//           included with the Work. (Exceptions: if the Program is interactive
//           but normally prints or displays such an announcement only at the
//           request of a user, such as in an "About box", the Work is required
//           to print or display the notice only under the same circumstances;
//           if the Program itself is interactive but does not normally print
//           such an announcement, the Work is not required to print an
//           announcement.);
//      (iv) You must accompany the Work with the complete corresponding
//           machine-readable source code, delivered on a medium customarily
//           used for software interchange. The source code for a work means
//           the preferred form of the work for making modifications to it. For
//           an executable work, complete source code means all the source code
//           for all modules it contains, plus any associated interface
//           definition files, plus the scripts used to control compilation and
//           installation of the executable code. If you distribute with the
//           Work any component that is normally distributed (in either source
//           or binary form) with the major components (compiler, kernel, and
//           so on) of the operating system on which the executable runs, you
//           must also distribute the source code of that component if you have
//           it and are allowed to do so;
//      (v)  If you distribute any written or printed material at all with the
//           Work, such material must include either a written copy of this
//           License, or a prominent written indication that the Work is
//           covered by this License and written instructions for printing
//           and/or displaying the copy of the License on the distribution
//           medium;
//      (vi) You may not impose any further restrictions on the recipient's
//           exercise of the rights granted herein.

// If distribution of executable or object code is made by offering the
// equivalent ability to copy from a designated place, then offering equivalent
// ability to copy the source code from the same place counts as distribution
// of the source code, even though third parties are not compelled to copy the
// source code along with the object code.

// 3. Reservation of Rights.

// No rights are granted to the Program except as expressly set forth herein.
// You may not copy, modify, sublicense, or distribute the Program except as
// expressly provided under this License. Any attempt otherwise to copy,
// modify, sublicense or distribute the Program is void, and will automatically
// terminate your rights under this License. However, parties who have received
// copies, or rights, from you under this License will not have their licenses
// terminated so long as such parties remain in full compliance.

// 4. Other Restrictions.

// If the distribution and/or use of the Program is restricted in certain
// countries for any reason, Licensor may add an explicit geographical
// distribution limitation excluding those countries, so that distribution is
// permitted only in or among countries not thus excluded. In such case, this
// License incorporates the limitation as if written in the body of this
// License.

// 5. Limitations.

// THE PROGRAM IS PROVIDED TO YOU "AS IS," WITHOUT WARRANTY. THERE IS NO
// WARRANTY FOR THE PROGRAM, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. THE ENTIRE
// RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD
// THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
// REPAIR OR CORRECTION.

// IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
// LICENSOR, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM
// AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL,
// SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
// INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
// DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES
// OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF
// SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
// DAMAGES.

// 6. General.

// This License is governed by the copyright laws of the European Union, 
// excluding choice of law rules.

// If any part of this License is found to be in conflict with the law, that
// part shall be interpreted in its broadest meaning consistent with the law,
// and no other parts of the License shall be affected.

// For United States Government users, the Program is provided with RESTRICTED
// RIGHTS. If you are a unit or agency of the United States Government or are
// acquiring the Program for any such unit or agency, the following apply:

//     If the unit or agency is the Department of Defense ("DOD"), the
//     Program and its documentation are classified as "commercial
//     computer software" and "commercial computer software
//     documentation" respectively and, pursuant to DFAR Section
//     227.7202, the Government is acquiring the Program and its
//     documentation in accordance with the terms of this License. If the
//     unit or agency is other than DOD, the Program and its
//     documentation are classified as "commercial computer software" and
//     "commercial computer software documentation" respectively and,
//     pursuant to FAR Section 12.212, the Government is acquiring the
//     Program and its documentation in accordance with the terms of this
//     License.




#ifndef MAPH_LEXING_MINIMIZATION_
#define MAPH_LEXING_MINIMIZATION_  1

#include "partition.h"
#include "reachfunc.h"
#include "comp.h"

#include <concepts>
#include <stack>
#include <queue>

namespace lexing
{
   
   // Collect the states from from that have a c-transition into
   // into. 

   template< typename C > stateset
   transition_into( const stateset& from,
                    const std::vector< deltafromstate<C>> & delta,
                    const stateset& into, C c )
   {
      stateset result;

      for( auto st : from )
      {
         auto p = delta[ st.nr ]. noneps. find(c);
         if( p -> second != blocked &&
                into. contains( st + p -> second ))
         {
            result. insert( st );
         }
      }
      return result; 
   } 

  
   template< typename C, typename T > 
   requires std::three_way_comparable< T, std::weak_ordering > 
   partition 
   initialpartitionwithfuture( const classifier<C,T> & cl,
                               const std::vector< stateset > & backtransitions )
   {
      std::vector< comp< reachfunc<T>, T >> part; 
 
      for( size_t c = 0; c != cl. nrstates( ); ++ c )
      {
         part. push_back( { reachfunc<T> ( ), cl. classifications[c] } );
      }

      std::queue< size_t > unchecked;
         // Check what works better, stack or queue.

      for( size_t c = 0; c != cl. nrstates( ); ++ c ) 
         unchecked. push(c);

      while( unchecked. size( ))
      {
         auto u = unchecked. front( ); unchecked. pop( ); 
        
         for( state b : backtransitions[u] )
         {
            bool change = false; 

            change |= part[ b. nr ]. first. insert( part[u]. second, 1 );

            for( const auto& r : part[u]. first )
               change |= part[ b. nr ]. first. insert( r.first, r.second + 1 ); 

            if( change ) 
               unchecked. push( b. nr );
         }
      }

      if constexpr( false ) 
      {
         for( size_t c = 0; c != cl. nrstates( ); ++ c )
         {
            std::cout << state(c) << " : " << part[c] << "\n";
         } 

         std::cout << "(note that states are currently not sorted)\n";
      }

      std::map< comp< reachfunc<T>, T >, stateset > classindex; 

      for( size_t c = 0; c != cl. nrstates( ); ++ c )
      {
         const auto& r = part[c];
         classindex[r]. insert(c);
      }

      return classindex;
   }


   template< typename C, typename T >
   requires std::three_way_comparable< T, std::weak_ordering >
   partition
   initialpartition( const classifier<C,T> & cl )
   {
      std::map< T, stateset > classindex;
         // Here we need order on T.

      for( size_t i = 0; i != cl. nrstates( ); ++ i )
      {
         const T& t = cl. classifications[i];
         classindex[t]. insert(i);
      }

      partition part = std::move( classindex );
      return part;
   }

 
   template< typename C, typename T > 
   std::vector< stateset > 
   computebacktransitions( const classifier<C,T> & cl )
   {
      std::vector< stateset > back( cl. nrstates( ), stateset( )); 

      for( size_t i = 0; i != cl. nrstates( ); ++ i ) 
      {
         for( const auto& pr : cl. delta[i]. noneps )
         {
            if( pr. second != blocked )
            {
               state target = state(i) + pr. second; 
               back[ target. nr ]. insert( state(i) );
            }
         }
      }

      if constexpr( false )
      {  
         std::cout << "Back Transitions:\n\n";
         for( size_t i = 0; i != back. size( ); ++ i )
            std::cout << i << ":   " << back[i] << "\n";
      }
      return back;
   }

   
   // Divide the automaton by the given state partition:
 
   template< typename C, typename T > 
   classifier<C,T> 
   quotient( const classifier<C,T> & cl, 
             const partition& part )
   {
      T error = cl. errorclass( );

      classifier<C,T> simp( error ); 
      simp. delta. clear( );
      simp. classifications. clear( );
 
      // We need to be sure that state 0 is mapped to zero.
      // If you see this error, either change the std::swap in partition, 
      // or solve the problem here. Removing the swap is 
      // certainly the easiest solution. You can also 
      // add a method to partition that solves this problem. 
      // I am not even sure if it can happen. 

      if( part.index[0] != 0 )
         throw std::runtime_error( "this must not happen" );
 
      for( size_t st = 0; st != part. eqclass. size( ); ++ st )
      {
         state repr = *part. eqclass[st]. begin( );  

         flatmap< C, int > noneps; 

         for( const auto& p : cl. delta[ repr. nr ]. noneps )
         {
            if( p. second != blocked )
            {
               state to = repr + p. second; 
               to = part. index[ to. nr ];  
               noneps. append( p. first, to - st );
            }
            else
            {
               noneps. append( p. first, blocked ); 
            }
         }
 
         simp. delta. push_back( deltafromstate<C>( std::set<int>(),
                                                    std::move( noneps ) ));
         simp. classifications. push_back( cl. classifications[ repr. nr ] );
      }

      return simp;
   }


   // The token tyes T must be ordered because we index on them.
   // It does not need to be a meaningful order, but
   // we need a total order. 
 
   template< typename C, typename T > 
   classifier<C,T> 
   minimize( const classifier<C,T> & cl )
   {
      if( cl. nrstates( ) == 0 )
         throw std::logic_error( "minimize: need at least one state" );

      for( const auto& d : cl. delta )
      {
         if( d. eps. size( ))
            throw std::runtime_error( 
                           "minimize: classifier is not deterministic" );
      }

      auto backtransitions = computebacktransitions( cl ); 
         // backtransitions[s] is the set of states that have a transition into 
         // state(s). 

      partition part = initialpartitionwithfuture( cl, backtransitions ); 

      if( !part. wellformed( )) 
         throw std::runtime_error( "obviously a major malfunction" ); 
            // You may start looking looking very carefully into the situation.

      if constexpr( false )
      {
         std::cout << "Initial Partition:\n";
         std::cout << part << "\n";
      }

      std::stack< size_t > unchecked;
         // It clearly follows from the literature that
         // stack is better than queue.

      for( size_t i = 0; i != part. eqclass. size( ); ++ i )
         unchecked. push(i);

      // unchecked contains indices of part. eqclass[] of classes
      // that need to checked against.

      while( unchecked. size( ))
      {
         size_t u = unchecked. top( ); unchecked. pop( );

         // std::cout << "picked equivalence class #" << u << " = ";
         // std::cout << part. eqclass[u] << "\n";

         stateset pred; 
            // We need the full set of predecessors.

         for( state s : part. eqclass[u] )
         {
            for( auto& b : backtransitions[ s. nr ] )
               pred. insert(b); 
         }

         // std::cout << "set of its predecessors " << pred << "\n";

         std::set<C> bord = borders( cl. delta, pred ); 

         // std::cout << "set of its borders " << bord << "\n";

         for( C b : bord )
         {
            // Determine the set of states that go into u.

            stateset filter = 
               transition_into( pred, cl. delta, part. eqclass[u], b );

            if( filter. size( ))
            {
               // std::cout << "border " << b << "\n";
               // std::cout << "results in non-empty filter " << filter << "\n";

               part. refine( filter, unchecked );
            }
         }
      } 

      part. sortbyminimum( ); 
      return quotient( cl, part ); 
   }


}


#endif


