struct Type
{
    const std::string name;
    void* data;

    explicit Type(std::string_view name, void* data = nullptr) : name(name), data(data) {};

    Type(const Type& another) : Type(another.name, another.data) {}

    virtual ~Type() { delete data; }
};

struct StructType : public Type
{
    std::vector <Type*> vals;

    explicit StructType(std::string_view name) : Type(name, nullptr), vals() {};
    explicit StructType(std::string_view name, std::vector <Type*>&& vals) : Type(name, nullptr), vals(std::move(vals)) {};

    StructType(const StructType& another) : Type(another.name, another.data), vals(another.vals) {}

    void AddType(Type* new_type) noexcept
    {
        vals.push_back(new_type);
    }

    virtual ~StructType() { std::for_each(vals.begin(), vals.end(), [](Type* t) { delete t; }); }
};

struct PropertyType : public Type
{
    std::map <std::string, StructType> syntax_table;

    PropertyType(std::string_view name) : Type(name, nullptr) {};
    
    void AddOption(std::string_view option_name, StructType struct_type) noexcept
    {
        syntax_table.emplace(option_name, struct_type);
    }

    const StructType& MatchOption(std::string_view option_name)
    {
        return syntax_table.at(option_name.data());
    }
};

std::map <std::string, Type*> syntax_table;
